from kyaml import KYAML
from pkgMng import *
from prompt import *
from writer import *
from os import mkdir


class ProjectConstructor:
  """ Holds functions for generating a project. """

  def __init__(self, _prompt: Prompt) -> None: self.lib, self.prompt = _prompt.get_library(), _prompt

  def gen_project(self) -> None:
    match self.lib:
      case DiscordLibrary.DISCORD_JS: self.__gen_djs_project()
      case DiscordLibrary.DISCORD_PY: self.__gen_dpy_project()
      case DiscordLibrary.PYCORD: self.__gen_pycord_project()
      case DiscordLibrary.JDA: self.__gen_jda_project()
      case DiscordLibrary.CONCORD: self.__gen_concord_project()
      case DiscordLibrary.DISCATSHARP: self.__gen_discatsharp_project()
      case DiscordLibrary.DPP: self.__gen_dpp_project()
      case _: raise KrappyError("unknown library", 1)

  def __gen_djs_project(self) -> None:
    pm = PkgMng.get_js_package_manager()
    install_cmd = ''

    match pm:
      case JSPackageManager.NPM: install_cmd = "npm i"
      case JSPackageManager.PNPM: install_cmd = "pnpm i"
      case JSPackageManager.YARN: install_cmd = "yarn add"
      case JSPackageManager.BUN: install_cmd = "bun add"

    options = self.prompt.get_djs_options()
    options |= self.prompt.get_general_options()  # {str, str | bool}
    options |= self.prompt.get_path(str(options["name"]))
    options |= self.prompt.get_intents_and_partials()  # {str, list[str]}
    options |= self.prompt.get_token()

    path = str(options["path"]).replace('\\', '/')  # Windows moment...
    lang = str(options["language"])
    intents, partials = options["intents"], options["partials"]
    if not type(intents) == list or not type(partials) == list: raise KrappyError("intents and partials should each be of type 'list[str]'", 1)

    # `krappy.yaml`.
    Writer.write_src(f"""# Generated by Krappy, do not edit!\n
options:
  language: {options["language"]}
  module_type: {options["module_type"]}
  name: {options["name"]}
  globalcmds: {options["globalcmds"]}
  path: {path}
  pmi: {install_cmd}
""", "%s/krappy.yaml" %path)

    # `.env`.
    Writer.write_src(f"""TOKEN={options["token"]}
CLIENT_ID={options["clientid"]}
{f"GUILD_ID={options["guildid"]}" if "guildid" in options else ''}
""", "%s/.env" %path)

    # `package.json`.
    Writer.write_src(f"""{{
  "name": "{options["name"]}",
  "version": "1.0.0",
  "description": "Generated with Krappy :)",
  "main": "src/index.{lang}",
  "scripts": {{
    {""""test": "echo \\"Error: no test specified\\" && exit 1\"""" if lang == "js" else """"start": "npx ts-node src/index.ts",\n"dev": "npx ts-node-dev@2.0.0-0 src/index.ts\""""}
  }},
  "keywords": [],
  "author": "",
  "license": "ISC"
}}
""", "%s/package.json" %path)

    # Make directories.
    mkdir("%s/src" %path)
    mkdir("%s/src/commands" %path)
    mkdir("%s/src/commands/misc" %path)
    mkdir("%s/src/events" %path)
    mkdir("%s/src/types" %path)

    if pm == JSPackageManager.BUN:
      # `tsconfig.json | jsconfig.json`.
      Writer.write_src(f"""{{
  "compilerOptions": {{
    "lib": ["ESNext"],
    "module": "esnext",
    "target": "esnext",
    "moduleResolution": "bundler",
    "moduleDetection": "force",
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "composite": true,
    "strict": true,
    "downlevelIteration": true,
    "skipLibCheck": true,
    "jsx": "react-jsx",
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "types": [
      "bun-types" // add Bun global
    ]
  }}
}}""", f"{path}/{lang}config.json")

    if lang == "ts":  # TypeScript (🔥)
      # `src/types/command.ts`
      Writer.write_src(f"""import {{ ChatInputCommandInteraction }} from 'discord.js';
import Bot from '../bot';

export declare type Category = 'MISC' | 'MODERATION' // Add more categories here!

/**
 * https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-type
 */
export enum OptionType {{
  SUB_COMMAND = 1,
  SUB_COMMAND_GROUP = 2,
  STRING = 3,
  /** Any integer between -2^53 and 2^53 */
  INTEGER = 4,
  BOOLEAN = 5,
  USER = 6,
  /** Includes all channel types + categories */
  CHANNEL = 7,
  ROLE = 8,
  /** Includes users and roles */
  MENTIONABLE = 9,
  /** Any double between -2^53 and 2^53 */
  NUMBER = 10,
  /** https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-type */
  ATTACHMENT = 11
}}

export interface OptionData {{
  name: string;
  description: string;
  type: OptionType;
}}

export interface CommandData {{
  name: string;
  description: string;
  options?: OptionData[] | undefined;
}}

export interface CommandArgs {{
  data: CommandData;
  category: Category;
  userPermissions?: bigint[] | undefined;
  myPermissions?: bigint[] | undefined;
}}

/**
 * Base class for commands.
 */
export default abstract class Command {{
  private _data: CommandData;
  private _category: Category;
  private _userPermissions?: bigint[] | undefined;
  private _myPermissions?: bigint[] | undefined;

  constructor(args: CommandArgs) {{
    this._data = args.data;
    this._category = args.category;
    this._userPermissions = args.userPermissions;
    this._myPermissions = args.myPermissions;
  }}

  get data(): CommandData {{ return this._data; }}
  get category(): Category {{ return this._category; }}
  get userPermissions(): bigint[] {{ return this._userPermissions ?? []; }}
  get myPermissions(): bigint[] {{ return this._myPermissions ?? []; }}

  public abstract execute(interaction: ChatInputCommandInteraction, client: Bot): any;
}}
""", "%s/src/types/command.ts" %path)

      # `src/types/event.ts`
      Writer.write_src(f"""import Bot from '../bot';

export interface EventArgs {{
  name: string;
  once?: boolean | undefined;
}}

/**
 * Base class for events.
 */
export default abstract class Event {{
  private _name: string;
  private _once: boolean;

  constructor(args: EventArgs) {{
    this._name = args.name;
    this._once = args.once ?? false;
  }}

  get name(): string {{ return this._name; }}
  get once(): boolean {{ return this._once; }}

  public abstract execute(client: Bot, ...args: any[]): any;
}}
""", "%s/src/types/event.ts" %path)

      # `src/bot.ts`.
      Writer.write_src(f"""import {{ Client, ClientOptions, Collection }} from 'discord.js';
import {{ Routes }} from 'discord-api-types/v9';
import {{ REST }} from '@discordjs/rest';
import {{ glob }} from 'glob';
import Command, {{ CommandData }} from './types/command';
// import Button from './types/button';
import Event from './types/event';
// import Modal from './types/modal';
// import SelectMenu from './types/selectMenu';

export default class Bot extends Client {{
  public commands = new Collection<string, Command>();
  // public buttons = new Collection<string, Button>();
  // public selectMenus = new Collection<string, SelectMenu>();
  // public modals = new Collection<string, Modal>();

  private _cmdJSONArray: CommandData[] = [];

  constructor(options: ClientOptions) {{
    super(options);
  }}

  public async registerCommands(): Promise<void> {{
    const cmdFiles = await glob(`${{__dirname}}/commands/**/*.ts`, {{ absolute: true }});

    for (const file of cmdFiles) {{
      const {{ default: Command }} = await import(file);
      const command: Command = new Command();

      this.commands.set(command.data.name, command);
      this._cmdJSONArray.push(command.data);

      console.log(`Loaded ${{command.data.name}} command!`);
    }}

    {"const clientId = process.env['CLIENT_ID'] ?? '';\nconst guildId = process.env['GUILD_ID'] ?? '';" if "guildId" in options else "const clientId = process.env['CLIENT_ID'] ?? '';"}
    const rest = new REST({{ version: '9' }}).setToken(process.env['TOKEN'] ?? '');

    (async (): Promise<void> => {{
      try {{
        console.log(`Started refreshing ${{cmdFiles.length}} application (/) commands.`);

        const data: any = await rest.put(
          {"Routes.applicationGuildCommands(clientId, guildId)" if "guildId" in options else "Routes.applicationCommands(clientId)"},
          {{ body: this._cmdJSONArray }}
        );

        console.log(`Successfully reloaded ${{data.length}} application (/) commands!`);
      }} catch (err) {{
        console.log('Failed to refresh application commands.');
        return console.error(err);
      }}
    }})();
  }}

  public async registerEvents(): Promise<void> {{
    const eventFiles = await glob(`${{__dirname}}/events/**/*.ts`, {{ absolute: true }});

    for (const file of eventFiles) {{
      const {{ default: Event }} = await import(file);
      const event: Event = new Event();

      event.once ? this.once(event.name, async (...args) => event.execute(this, ...args))
      : this.on(event.name, async (...args) => event.execute(this, ...args));

      console.log(`Loaded ${{event.name}} event!`);
    }}
  }}

  // public async registerButtons(): Promise<void> {{ }}
  // public async registerSelectMenus(): Promise<void> {{ }}
  // public async registerModals(): Promise<void> {{ }}
}}
""", "%s/src/bot.ts" %path)

      # `src/index.ts`.
      Writer.write_src(f"""import {{ GatewayIntentBits, Partials }} from 'discord.js';
{"import Bot from './bot';" if pm == JSPackageManager.BUN else "import { config } from 'dotenv';\nimport Bot from './bot';\nconfig();"}

const client = new Bot({{
  intents: {f"{"[]" if not len(intents) > 0 else f"""[\n    {',\n    '.join(["GatewayIntentBits.%s" %i for i in intents]) if "All" not in intents else ',\n    '.join(["GatewayIntentBits.%s" %i for i in [i.value for i in Intent][1:]])}\n  ]"""}"},
  partials: {f"{"[]" if not len(partials) > 0 else f"""[\n    {',\n    '.join(["Partials.%s" %p for p in partials]) if "All" not in partials else ',\n    '.join(["Partials.%s" %p for p in [p.value for p in Partial][1:]])}\n  ]"""}"}
}});

(async (): Promise<void> => {{
  await client.registerEvents();
  await client.registerCommands();
  await client.login(process.env['TOKEN'] ?? '');
}})();
""", "%s/src/index.ts" %path)

      # `src/events/ready.ts`
      Writer.write_src(f"""import Event from '../types/event';
import Bot from '../bot';

export default class ReadyEvent extends Event {{
  constructor() {{
    super({{
      name: 'ready',
      once: true
    }});
  }}

  public async execute(client: Bot) {{
    return console.log(`Logged in as ${{client.user?.tag}}!`);
  }}
}}
""", "%s/src/events/ready.ts" %path)

      # `src/events/interactionCreate.ts`
      Writer.write_src(f"""import {{
  AnySelectMenuInteraction,
  ButtonInteraction,
  ChatInputCommandInteraction,
  ModalMessageModalSubmitInteraction,
  ModalSubmitInteraction
}} from 'discord.js';
import Command from '../types/command';
import Event from '../types/event';
import Bot from '../bot';

export default class InteractionCreateEvent extends Event {{
  constructor() {{
    super({{
      name: 'interactionCreate'
    }});
  }}

  public async execute(client: Bot, interaction: AnySelectMenuInteraction |
  ButtonInteraction |
  ChatInputCommandInteraction |
  ModalMessageModalSubmitInteraction |
  ModalSubmitInteraction) {{
    // Application (/) command.
    if (interaction.isChatInputCommand()) {{
      // vvv Comment out this line if you want commands to run in DMs.
      if (interaction.channel?.isDMBased()) return;

      const command: Command | undefined = client.commands.get(interaction.commandName);
      if (!command) return;

      if (!interaction.memberPermissions?.has(command.userPermissions))
        return await interaction.reply({{ content: 'You don\\'t have permission to use this command!', ephemeral: true }});

      try {{
        return await command.execute(interaction, client);
      }} catch (err) {{
        await interaction.reply({{ content: `Error while executing command:\\n\\`\\`\\`ts\\n${{err}}\\n\\`\\`\\``, ephemeral: true }});
        return console.error(err);
      }}
    }}

    else if (interaction.isButton()) {{ }}
    else if (interaction.isAnySelectMenu()) {{ }}
    else if (interaction.isModalSubmit()) {{ }}
  }}
}}
""", "%s/src/events/interactionCreate.ts" %path)

      # `src/commands/misc/ping.ts`
      Writer.write_src(f"""import {{ ChatInputCommandInteraction }} from 'discord.js';
import Bot from '../../bot';
import Command from '../../types/command';

export default class PingCommand extends Command {{
  constructor() {{
    super({{
      data: {{
        name: 'ping',
        description: 'Pong!'
      }},
      category: 'MISC'
    }});
  }}

  public async execute(interaction: ChatInputCommandInteraction, client: Bot) {{
    return await interaction.reply({{ content: 'Pong!' }});
  }}
}}
""", "%s/src/commands/misc/ping.ts" %path)

    else:  # JavaScript (🗑️)
      ...

    # Install packages and conclude.
    PkgMng(path, install_cmd, "discord.js", "glob", "dotenv" if not pm == JSPackageManager.BUN else None).install()
    self.conclude(path)

  def conclude(self, _path: str) -> None:
    print("Successfully generated in %s!" %_path)
    exit(0)  # Imported from `prompt.py`.

  def __gen_dpy_project(self) -> None: print("To be supported...")
  def __gen_pycord_project(self) -> None: print("To be supported...")
  def __gen_jda_project(self) -> None: print("To be supported...")
  def __gen_concord_project(self) -> None: print("To be supported...")
  def __gen_discatsharp_project(self) -> None: print("To be supported...")
  def __gen_dpp_project(self) -> None: print("To be supported...")


class CommandConstructor:
  """ Holds functions for generating a command. """

  def __init__(self, _prompt: Prompt) -> None: self.lib, self.prompt = _prompt.get_library(), _prompt

  def gen_command(self) -> None:
    match self.lib:
      case DiscordLibrary.DISCORD_JS: self.__gen_djs_command()
      case DiscordLibrary.DISCORD_PY: self.__gen_dpy_command()
      case DiscordLibrary.PYCORD: self.__gen_pycord_command()
      case DiscordLibrary.JDA: self.__gen_jda_command()
      case DiscordLibrary.CONCORD: self.__gen_concord_command()
      case DiscordLibrary.DISCATSHARP: self.__gen_discatsharp_command()
      case DiscordLibrary.DPP: self.__gen_dpp_command()
      case _: raise KrappyError("unknown library", 1)

  def __gen_djs_command(self) -> None: print("To be supported...")
  def __gen_dpy_command(self) -> None: print("To be supported...")
  def __gen_pycord_command(self) -> None: print("To be supported...")
  def __gen_jda_command(self) -> None: print("To be supported...")
  def __gen_concord_command(self) -> None: print("To be supported...")
  def __gen_discatsharp_command(self) -> None: print("To be supported...")
  def __gen_dpp_command(self) -> None: print("To be supported...")


class EventConstructor:
  """ Holds functions for generating a event. """

  def __init__(self, _prompt: Prompt) -> None: self.lib, self.prompt = _prompt.get_library(), _prompt

  def gen_event(self) -> None:
    match self.lib:
      case DiscordLibrary.DISCORD_JS: self.__gen_djs_event()
      case DiscordLibrary.DISCORD_PY: self.__gen_dpy_event()
      case DiscordLibrary.PYCORD: self.__gen_pycord_event()
      case DiscordLibrary.JDA: self.__gen_jda_event()
      case DiscordLibrary.CONCORD: self.__gen_concord_event()
      case DiscordLibrary.DISCATSHARP: self.__gen_discatsharp_event()
      case DiscordLibrary.DPP: self.__gen_dpp_event()
      case _: raise KrappyError("unknown library", 1)

  def __gen_djs_event(self) -> None: print("To be supported...")
  def __gen_dpy_event(self) -> None: print("To be supported...")
  def __gen_pycord_event(self) -> None: print("To be supported...")
  def __gen_jda_event(self) -> None: print("To be supported...")
  def __gen_concord_event(self) -> None: print("To be supported...")
  def __gen_discatsharp_event(self) -> None: print("To be supported...")
  def __gen_dpp_event(self) -> None: print("To be supported...")
